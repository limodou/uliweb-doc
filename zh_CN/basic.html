<!DOCTYPE html>
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="">
<meta name="author" content="">

<link rel="stylesheet" href="./static/semantic/css/semantic.min.css"/>
<link href="./static/asset/prettify.css" rel="stylesheet">
<link href="./static/toc/toc.css" rel="stylesheet">
<link rel="stylesheet" href="./static/parm.css"/>
<link rel="stylesheet" href="./static/asset/sons-of-obsidian.css"/>

<title>Simple Todo (Uliweb 版本) 之 基础篇 - Uliweb-Doc</title>
</head>
<body>



<!-- Navbar
================================================== -->
<div class="navbar">
  <div class="ui small secondary inverted borderless menu">
    
    <a class="active item" href="./index.html">Home</a><a class="item" href="https://github.com/limodou/uliweb">Uliweb Project</a>
    
    <div class="right menu">
      <div class="ui dropdown item">
        Select Languages <i class="icon dropdown"></i>
        <div class="menu">
          <a class="item language" href="#" data-lang="en">English</a>
          <a class="item language" href="#" data-lang="zh_CN">中文</a>
        </div>
      </div>
    </div>
  </div>
</div>


<div class="ui divided grid">
    <div class="four wide column" id="side-bar">
        <div id="toc" class="content"></div>
    </div> 
    
    <div class="twelve wide column" id="markdown-content">
    
        <div class="chapter-prev chapter-top">
    <a prev-chapter href="./hello_uliweb.html"><i class="icon-arrow-left"></i> Hello, Uliweb</a>
</div>
<div class="chapter-next chapter-top">
    <a next-chapter href="./plugs_todo.html">Simple Todo (Uliweb 版本) 之 高级篇 <i class="icon-arrow-right"></i></a>
</div>
        
        <h1 id="title_1">Simple Todo (Uliweb 版本) 之 基础篇<a class="anchor" href="#title_1">&para;</a></h1>
<p>本版本是从 <a href="http://simple-is-better.com/news/detail-309" class="outter">http://simple-is-better.com/news/detail-309</a> 来的，原版本基于web.py开 发的，看到这个应用相对简单，因此我将其改造为uliweb的版本。在uliweb版本中，我会列 举详细的开发过程，同时会指出与web.py的一些差异，有兴趣的可以比较。不过，因为我 没有学过web.py，因此只能从原始代码中进行理解，并推测，如果有说得不对的地方欢迎 与我交流，共同学习。</p>
<p>为什么叫基础篇？因为有基础必然有提高篇，其实目前uliweb已经提供了一些相对实用的 模块或app，可以用来快速开发。在提高篇中我希望使用这些内容重新再写一下Todo这个应 用。因此你会看到有关于plugs和generic view的一些使用。</p>
<p>原始的web.py的版本代码可以从上面的网址找到，那么为了简化，我使用了它的一些文件， 比如样式之类的。好，下面让我们开始体验如何使用uliweb开发这样的todo程序。</p>
<div class="ui warning message">
<p>关于如何安装uliweb这里不再描述了，有兴趣地找一找Hello, Uliweb文档。</p>

</div>
<h2 id="title_1-1">构建流程<a class="anchor" href="#title_1-1">&para;</a></h2>
<h3 id="title_1-1-1">创建项目<a class="anchor" href="#title_1-1-1">&para;</a></h3>
<p>进入一个初始目录（假定为$project），开始创建项目。</p>
<p>进入命令行，执行:</p>
<pre class="prettyprint"><code>uliweb makeproject simple_todo</code></pre>
<p>上面的命令会在$project下创建一个simple_todo的目录，这个就是我们的项目的目录。</p>
<h3 id="title_1-1-2">创建todo App<a class="anchor" href="#title_1-1-2">&para;</a></h3>
<p>uliweb的project是由若干个app组成，所以进入simple_todo目录，然后在命令行执行:</p>
<pre class="prettyprint"><code>cd simple_todo
uliweb makeapp todo</code></pre>
<p>执行成功后，会在simple_todo/apps下生成一个todo的目录，它就是我们将用来写代码的 主要目录。</p>
<h2 id="title_1-2">功能分析<a class="anchor" href="#title_1-2">&para;</a></h2>
<p>通过阅读源码和查看运行结果的画面，我们可以了解到：这个todo可以支持：</p>
<ul>
<li>显示列表（无翻页）</li>
<li>显示的同时可以删除和修改</li>
<li>在显示页面上可以直接添加</li>
</ul>
<p>原教程的数据库配置是使用mysql，这里我使用sqlite，因为比较方便。</p>
<h2 id="title_1-3">基本页面布局<a class="anchor" href="#title_1-3">&para;</a></h2>
<p>为了实现整体的页面布局效果，这里我会创建一个基础的layout.html，它是其它模板的父 模板。（看了原始代码，好象web.py没有模板继承的概念，因此你会看到一个完整的模板 是分散到index.html, header.html和foot.html中去了，这里我们要重构一下。）</p>
<p>在simple_todo/apps/todo/templates下创建layout.html文件。</p>
<p>templates目录是专门用来存放模板文件的地方。</p>
<p>首先是layout.html，以下是修改后的代码:</p>
<pre class="prettyprint"><code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;title&gt;{{=settings.SITE.SITE_NAME}}&lt;/title&gt;
&lt;link href="{{=url_for_static('styles/reset.css')}}" rel="stylesheet" type="text/css" /&gt;
&lt;link href="{{=url_for_static('styles/index/style.css')}}" rel="stylesheet" type="text/css" /&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div class="page"&gt;
    &lt;div class="header box"&gt;
        &lt;h1&gt;&lt;a href="/"&gt;{{=settings.SITE.SITE_NAME}}&lt;/a&gt;&lt;/h1&gt;
    &lt;/div&gt;
    &lt;div class="main box"&gt;
    {{block content}}{{end}}
    &lt;/div&gt;
    &lt;div class="foot"&gt;
        Copyright&amp;copy; {{=settings.SITE.SITE_NAME}} 作者： {{=settings.SITE.EMAIL}}
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>在这里，原来web.py中的变量写法是$config.site_name，变成了{{=settings.SITE.SITE_NAME}}。 在uliweb中，有自已的settings.ini文件，用来存放配置信息，而web.py是使用Python源 文件，uliweb使用类ini文件(**它其实是使用自已定义的pyini的格式**)。</p>
<p>最重要的一点:</p>
<pre class="prettyprint"><code>&lt;div class="main box"&gt;
{{block content}}{{end}}
&lt;/div&gt;</code></pre>
<p>这里定义了一个block，它和django的差不多。不过结束标记不是{{endblock}}而是{{end}}。 原来的web.py版本没有类似的用法。</p>
<p>再有就是这里了:</p>
<pre class="prettyprint"><code>&lt;link href="{{=url_for_static('styles/reset.css')}}" rel="stylesheet" type="text/css" /&gt;</code></pre>
<p>使用{{=url_for_static()}}来生成静态链接。原来的程序是使用:</p>
<pre class="prettyprint"><code>$config.static/styles/reset.css</code></pre>
<p>这是不一样的地方。</p>
<div class="ui warning message">
<p>注意，整个uliweb的教程全部使用utf-8编码（主要指模板及程序文件），以后也建议你使用utf-8编码。</p>

</div>
<h2 id="title_1-4">静态文件处理<a class="anchor" href="#title_1-4">&para;</a></h2>
<p>为了方便，我从原来的版本中拷贝了styles目录到simple_todo/apps/todo/static 中去。</p>
<h2 id="title_1-5">settings.ini配置<a class="anchor" href="#title_1-5">&para;</a></h2>
<p>下面配置一下settings.ini文件。</p>
<p>打开simple_todo/apps/settings.ini文件，将其改为:</p>
<pre class="prettyprint"><code>[GLOBAL]
DEBUG = True

INSTALLED_APPS = [
    'uliweb.contrib.staticfiles',
    'todo',
    ]

[SITE]
SITE_NAME = '任务跟踪'
EMAIL = 'limodou@gmail.com'</code></pre>
<p>其中在INSTALLED_APPS中添加了todo。 'uliweb.contrib.staticfiles'是用来专门处理 静态文件的app。</p>
<p>然后是定义了SITE，在下面又定义了SITE_NAME和EMAIL。这里可以使用大写或小写。象django 是必须使用大写的。uliweb的settings.ini格式看上去和ini格式差不多，都是以section 为分隔，然后是key=value的形式。不过，这里的value可以是任意简单的python数据结构， 比如dict, list, tuple, string, unicode等。如果第一行加上#coding=<encoding>，还 可以声明这个ini文件的编码格式。</p>
<h2 id="title_1-6">第一次运行<a class="anchor" href="#title_1-6">&para;</a></h2>
<p>上面的代码目前还无法运行。不过我想看一看大概是什么样了，怎么办。因为目前，我们只 完成了：</p>
<ul>
<li>layout.html模板</li>
<li>settings.ini的基本定义（数据库还没定义）</li>
</ul>
<p>所以还差得远了。为了运行，我们首先要修改一下simple_todo/apps/todo/views.py，改 为:</p>
<pre class="prettyprint"><code>#coding=utf-8
from uliweb import expose

@expose('/')
def index():
    return {}</code></pre>
<p>上面的代码，将定义一个views函数。使用@expose来定义它对应的url。这是与web.py和django 不同的地方。在uliweb中，url一般是定义在views.py文件中的，通过decorator与view函数 进行绑定。</p>
<p>上面index()将返回一个{}。那么表示它将使用缺省的模板，模板名就和view函数名一样， 在这里是index。所以我们还需要在todo/templates中定义一个index.html。</p>
<p>本来，index.html中需要定义如果展示todo的内容，但是因为目前数据库等内容还没有创建， 所以我们只想显示空的内容。</p>
<p>在todo/templates下创建index.html，内容为:</p>
<pre class="prettyprint"><code>{{extend "layout.html"}}</code></pre>
<p>的确，目前只有这一行代码。它表示从layout.html这个父模板中进行继承。</p>
<p>好，目前差不多了，让我们回到命令行，在simple_todo目录下运行:</p>
<pre class="prettyprint"><code>uliweb runserver</code></pre>
<p>如果没有错误，则会看到:</p>
<pre class="prettyprint"><code>* Loading DebuggedApplication...
* Running on http://localhost:8000/
* Restarting with reloader...
* Loading DebuggedApplication...</code></pre>
<p>说明，开发服务器已经准备完毕了，可以通过访问 <a href="http://localhost:8000" class="outter">http://localhost:8000</a> 来看效果了。 可以看到如下的效果:</p>
<p><img src="_static/first.png" alt="image"/>
</p>
<h2 id="title_1-7">添加数据库配置<a class="anchor" href="#title_1-7">&para;</a></h2>
<p>基本架子已经搭好。下面是进行数据库配置。</p>
<p>打开apps/settings.ini，修改为:</p>
<pre class="prettyprint"><code>[GLOBAL]
DEBUG = True

INSTALLED_APPS = [
    'uliweb.contrib.staticfiles',
    'uliweb.contrib.orm',
    'todo',
    ]

[SITE]
SITE_NAME = '任务跟踪'
EMAIL = 'limodou@gmail.com'

[ORM]
CONNECTION = 'sqlite:///database.db'
AUTO_CREATE = False</code></pre>
<p>这里的重点是添加'uliweb.contrib.orm'这个app，然后是将它要使用的配置信息放在[ORM] 中，这里主要是配置了sqlite数据库，并且使用了相对路径，因此，以后再运行时，database.db 将会在simple_todo这个目录下。</p>
<p>注意AUOT_CREATE=False，它的作用就是当使用某个Model时，不自动创建Model。缺省情况 下是自动创建，这样只要Model不存在，Uliweb就会自动创建。但是发现对于sqlite，如果 在事务中，执行了非select, update, delete等语句，会引发事务自动提交，造成不一致。 因此这里我就把它关掉了。</p>
<div class="ui warning message">
<p>Uliweb有自已的ORM，你可以选择使用，也可以选择不使用。这里是使用了自带的ORM。 同时Uliweb的ORM是基于sqlalchemy开发的，因此上面的数据库连接串是和sqlalchemy 一致的。</p>

</div><p>原来版本中使用的是mysql，如果你想试一下，可以将上面的CONNECTION的内容改为:</p>
<pre class="prettyprint"><code>CONNECTION = 'mysql://todo:123456@localhost/todo?charset=utf8'</code></pre>
<p>最后的charset=utf8可以根据需要来选择，这里会强制设置client使用utf8编码。</p>
<h2 id="title_1-8">创建Todo的Model<a class="anchor" href="#title_1-8">&para;</a></h2>
<p>有了库，下面就是创建表结构。在todo下创建models.py文件，写入以下内容:</p>
<pre class="prettyprint"><code>#coding=utf-8
from uliweb.orm import *

class Todo(Model):
    title = Field(str, verbose_name="标题", max_length=255, required=True)
    post_date = Field(datetime.datetime, verbose_name='提交时间', auto_now_add=True)
    finished = Field(bool, verbose_name='是否完成')</code></pre>
<p>这里我们定义了3个字段。因为我没有发现web.py版本中有创建表的内容，所以我根据代码 理解大概有这么几个字段。不过原版本好象没有实现完成状态的设置，所以我这里预留了。</p>
<p>让我看一下代码。在Uliweb中，可以通过从Model派生出新的子类。它和django的Model类似。 不过这里在定义字段时有两种方式，一种是直接使用真正的字段类，如：StringProperty, DatetimeProperty，不过这种不是很好记忆，而且输入字符比较多，因此还提供简化的定义 方式。通过Field()函数来定义，它的第一个参数是字段的类型，都是基本的Python type对象， 如：str, bool, int, flat, datetime, date等。但是有一些数据库结构中有，但是不存在 对应的Python类型，如：TEXT，等，或需要单独导入的某些特殊的类，如：decimal.Decimal 等，在uliweb，分别定义了大写的类型，如：TEXT, BLOB, DECIMAL可以直接使用。</p>
<p>其它的参数相对直观。对于post_date字段，使用了auto_now_add=True，它的作用就是 当创建新记录时，会自动使用系统当前时间填充，这样你可以不用给它赋值。这一点和 django的一样。</p>
<div class="ui warning message">
<p>在定义Model时，我们一般使用首字母大写的单词作为Model的名字。但是uliweb会自 动将其转为小写。所以Todo类对应的表名，其实是todo。</p>

</div><p>定义完Todo后，我们还有一项配置工作，那就是把Model配置到settings.ini中去。有两种 做法，一种是放到apps/settings.ini中去，但是这样不方便移植，所以还可以放到todo/settings.ini 中去。不过现在没有这个文件，因此让我们创建一个，然后输入以下内容:</p>
<pre class="prettyprint"><code>[MODELS]
todo = 'todo.models.Todo'</code></pre>
<p>key是todo，即真正的表名，值是todo对应的类的路径，格式为：app_name.models.Model_name</p>
<p>下面，让我们在命令行下创建这个表。其实，如果不设置前面的AUTO_CREATE = False，则 随着运行，Todo表会自动创建，但是现在让我们手工创建，顺便看一看会不会报错。</p>
<p>在命令行下运行:</p>
<pre class="prettyprint"><code>uliweb -v syncdb</code></pre>
<p>可以看到:</p>
<pre class="prettyprint"><code>Creating todo...</code></pre>
<p>然后还可以输出相应的建表的sql语句:</p>
<pre class="prettyprint"><code>&gt; uliweb sql

CREATE TABLE todo (
        post_date DATETIME,
        finished BOOLEAN,
        id INTEGER,
        title VARCHAR(255),
        PRIMARY KEY (id),
        CHECK (finished IN (0, 1))
)</code></pre>
<p>如果我们到simple_todo目录下看，可以发现database.db已经创建好了。</p>
<p>等等，上面怎么好象多了一个id的字段。没错，和django一样，uliweb orm会自动为每个 表创建一个id的字段。</p>
<h2 id="title_1-9">显示Todo<a class="anchor" href="#title_1-9">&para;</a></h2>
<p>下面开始写展示Todo列表的代码了，让我们先从模板开始。我们需要再次编辑index.html了， 让我们写入下面的代码:</p>
<pre class="prettyprint"><code>{{extend "layout.html"}}

{{block content}}
&lt;div class="box"&gt;
    &lt;div class="box todos"&gt;
        &lt;h2 class="box"&gt;待办事项&lt;/h2&gt;
        &lt;ul&gt;
            {{for todo in todos:}}
                &lt;li&gt;
                    {{=todo.title}}
                    &amp;nbsp;
                    &lt;span class="action"&gt;
                        &lt;a href="/todo/edit/{{=todo.id}}"&gt;修改&lt;/a&gt;,
                        &lt;a href="/todo/delete/{{=todo.id}}"
                            onclick="return confirm('删除以后不能恢复的，确定？')"&gt;删除&lt;/a&gt;
                    &lt;/span&gt;
                &lt;/li&gt;
            {{pass}}
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div class="box post"&gt;
        &lt;h2&gt;新增&lt;/h2&gt;
        &lt;form action="/todo/new" method="post" id="post_new"&gt;
            &lt;p&gt;&lt;input type="text" name="title" class="long_txt" /&gt;&lt;/p&gt;
            &lt;p&gt;&lt;input type="submit" class="submit" value="添加" /&gt;&lt;/p&gt;
        &lt;/form&gt;
    &lt;/div&gt;
&lt;/div&gt;
{{end}}</code></pre>
<p>这段代码是我从web.py版本中拷贝并修改的，它主要包含两部分：</p>
<ol>
<li>显示Todo列表的循环</li>
<li>显示添加新的Todo的内容</li>
</ol>
<p>第一部分比较简单，我们希望向模板中传入一个todos的变量，它其实是所有todo的一个列表。 然后，在模板中进行循环。Uliweb的模板可以直接写Python代码，所以for后面的':'不要忘了。 同时for结束（包括其它的块语句结束，如：if, def, while等）都要在后面加上{{pass}}， 用来标识块缩近结束。所以在uliweb中你不用考虑缩近，但是要在适应的位置加上{{pass}}。</p>
<p>在循环中，我们会显示Todo的标题，同时展示两个链接。这里我使用了和web.py版本不同的 格式，原来的是/todo/id/edit，看上去更RESTFul一些，我使用的是/todo/edit/id，为什么？ 其实也可以和原版本保持一致，不过，我想在views.py中展示如何使用class view的写法， 如何省事，所以就使用了这种格式。写成原来的格式也是可以的。</p>
<p>模板准备好了，下面写views.py了。</p>
<p>最开始我们运行时，我们看到在views.py中定义了一个函数，这是和django相一致的。现在 django 1.3已经支持class方式的view了，Uliweb中也支持类似的方式，不过和django的差 异很大。同时和web.py的方式也不同。我看web.py的方式和django的更接近一些。</p>
<p>通过看原版本代码，web.py的类只用来处理一个URL，同时可以区分不同的方法，如：GET, POST 等。而uliweb对GET, POST的区分是通过URL的定义来实现的，class本身可以同时支持多个URL。 因此，在原版本中，你会在todo.py中看到针对不同的请求，分别定义了：New, Edit, Delete, Index。 而我将只用一个Todo类来定义，增加不同的方法。</p>
<p>views.py 的代码如下:</p>
<pre class="prettyprint"><code>#coding=utf-8
from uliweb import expose

@expose('/todo')
class Todo(object):
    def __init__(self):
        from uliweb.orm import get_model

        self.model = get_model('todo')

    @expose('/')
    def index(self):
        return {'todos':self.model.all()}</code></pre>
<p>我把原来的代码删除了。简单解释一下：</p>
<ol>
<li>在Uliweb中class view的class可以是new style class，也可以是classic style class，     不过建议使用new style class。</li>
<li>类上也可以加@expose()，这样，类中所有的方法都会带上这个前缀，除非你覆盖它，正     如下面的index一样。</li>
<li>你可以在__init__中写一些初始化的代码。上面就是定义了要使用的model。这里get_model()     的使用是uliweb的一个创新（我认为是这样的）。虽然在前面，我们定义Model的时候好     象麻烦了点，因此还要修改settings.ini。但是这里就方便了。我们甚至不需要知道     todo表在哪里，就可以直接导入。</li>
<li>对于index，这里又定义了一个@expose('/')，那么它将会覆盖缺省的URL定义。</li>
<li>index将返回一个字典。获得一个Model的所以记录就是Model.all()。这里不象django     一样，还要加上objects，不需要。</li>
<li><p>原教程中在列出所有todo时还对id进行了升序排列，但是缺省都是按主键排列，而id正好是     主键，所以这里我就省了。当然，如果你想加的话可以这样:</p>
<pre class="prettyprint"><code>self.model.all().order_by(self.model.c.id)</code></pre></li>
</ol>
<p>这里的语法完全和sqlalchemy是一致的。在Model中有一个和sqlalchemy Table一样的     c属性，可以用来引用字段。这里就不多说了。</p>
<p>让我们运行一下，刷新一下界面。</p>
<p>不好，报错了，说是使用了“Default Template”，这是怎么回事？</p>
<p>因为我们使用了class view的方式，所以对于模板目录有一个小小的变化，那就是要在 templates中定义一个和Todo一样的目录，然后将index.html放到这个下面。这样，所有 在class view中定义的方法对应的模板都放到相应的类目录中。</p>
<p>改完以后，再运行，结果是这个样子。</p>
<p><img src="_static/view_index.png" alt="image"/>
</p>
<h2 id="title_1-10">实现新增Todo<a class="anchor" href="#title_1-10">&para;</a></h2>
<p>只要能添加就好办了。下面写添加代码:</p>
<pre class="prettyprint"><code>def new(self):
    title = request.POST.get('title')
    if not title:
        error('标题是必须的')
    todo = self.model(title=title)
    todo.save()
    return redirect(url_for(Todo.index))</code></pre>
<p>注意这是Todo的一个新方法，要注意缩近。解释一下：</p>
<ol>
<li>new上没有定义@expose()，所以它的url将会是/todo/new</li>
<li>有人要问，如果有些方法不想有真正的URL怎么办，那么所有以_开头的方法都不会对应     一个URL，也就不会被人访问到。</li>
<li><p>在uliweb，有些方法和变量是全局的，比如上面的：request, error, redirect，都是     可以直接使用的。如果你想显示地使用它们，可以通过:</p>
<pre class="prettyprint"><code>from uliweb import request, error, redirect</code></pre></li>
<li>error目前会引发一个异常，所以并不需要return</li>
<li>url_for可以反向获取一个URL，这里传入的是一个函数对应，所以url_for(Todo.index)     其实就是'/'。这种做法主要是因为：代码结构可能不容易变化，而URL却容易变化，通过     反向获取，会减少URL变化带来的修改。当然，你可以不用，直接写'/'。</li>
<li>在uliweb中，instance=Model(**kwargs)可以用来创建一条记录，当然要注意使用instance.save()     来保存。上面我们没有传入post_date，但是由于在Model定义时，我们加入了auto_now_add，     所以在创建新记录时，它会自动使用服务器的时间。</li>
<li>Uliweb的Request, Response目前是使用werkzeug（和Flask基础是一样的）库。</li>
</ol>
<p>上面的代码将判断是否有title，如果没有则报错。如果有，则保存。让我们运行一下。</p>
<p>让我们输入：这是一个测试</p>
<p><img src="_static/new.png" alt="image"/>
</p>
<p>如果我们什么都不输会怎么样？</p>
<p>怎么回事，又报错！晕啊，程序真是不好写，Uliweb不好玩啊。先看下界面吧:</p>
<p><img src="_static/error.png" alt="image"/>
</p>
<p>这是一个调试界面，在Uliweb中使用了werkzeug的调试器，可以在Debug状态下，当出错时 显示出错界面，非常不错。上面的错误就是找不到error.html模板。为什么？因为我们没 有定义这样的一个模板。好吧，让我们在todo/templates下创建一个，因为它不是与class view 对应，所以不需要放在Todo目录下。</p>
<p>创建的error.html代码如下:</p>
<pre class="prettyprint"><code>{{extend "layout.html"}}

{{block content}}
    &lt;div class="content"&gt;
        &lt;h1 style="font-weight:400;"&gt;
            出错了！{{=message}}
        &lt;/h1&gt;
        &lt;p&gt;
            &lt;a href="javascript: history.back();"&gt;返回&lt;/a&gt; |
            &lt;a href="/"&gt;首页&lt;/a&gt;
        &lt;/p&gt;
    &lt;/div&gt;
{{end}}</code></pre>
<p>这里放置一个message的变量，它是由error传入的。这个模板与web.py版本不完全一样，原 版本还有自动跳转，我这里没有。</p>
<p>这里我没有特别区分URL是GET还是POST，比如上面的new，如果希望使用POST接收，可以 在new上写:</p>
<pre class="prettyprint"><code>@expose(methods=['POST'])</code></pre>
<h2 id="title_1-11">修改Todo<a class="anchor" href="#title_1-11">&para;</a></h2>
<p>下面开始处理修改Todo了。首先创建模板吧，在Todo目录下创建edit.html，内容为:</p>
<pre class="prettyprint"><code>{{extend "layout.html"}}

{{block content}}
    &lt;div class="box post"&gt;
        &lt;h2&gt;修改&lt;/h2&gt;
        &lt;form action="" method="post"&gt;
            &lt;p&gt;&lt;input type="text" name="title" class="long_txt" value="{{=todo.title}}" /&gt;&lt;/p&gt;
                &lt;input type="submit" class="submit" value="提交" /&gt;
            &lt;/p&gt;
        &lt;/form&gt;
    &lt;/div&gt;
{{end}}</code></pre>
<p>这里没什么可讲的。</p>
<p>然后是写修改的view代码:</p>
<pre class="prettyprint"><code>def edit(self, id):
    todo = self.model.get(int(id))
    if not todo:
        error('没找到这条记录')
    if request.method == 'GET':
        return {'todo':todo}
    else:
        title = request.POST.get('title')
        if not title:
            error('标题是必须的')
        todo.title = title
        todo.save()
        return redirect(url_for(Todo.index))</code></pre>
<p>解释一下：</p>
<ol>
<li>现在edit有一个参数，那么自动生成的URL是什么样的？答案是/todo/edit/<id>，这也     就是为什么我前面要修改/todo/id/edit的原因，就是为了和class view生成的URL相一致。</li>
<li>edit这个函数在编辑时会执行两次，第一次是判断request.method=='GET'时，用于显示。     第二次是在修改后提交时，用于保存。在web.py的版本中，我们看到它是在Edit这个类中     通过定义了GET和POST方法来进行区分，而在Uliweb中则通过判断语句来进行区分，功能     一样，思路有所差别。不过，原来的版本中有关于记录是否存在的判断在GET和POST中     有相同的代码，而在Uliweb的版本中进行了合并。</li>
<li>使用self.model.get(id)就可以获得一个对象。如果不存在，会返回None，而不是异常。</li>
<li>todo.title = title 然后 todo.save() 这是典型的ORM操作。</li>
</ol>
<p>不过写到这里，和web.py版本有所不同。主要是在成功后，web.py版本会利用error页面， 因为它有自动跳转的功能，来显示成功后的信息。而我删除了，所以在我的版本中不会显示 修改成功后的信息。不过，如果要做有很多种方式 ，比如通过session机制。或使用uliweb 中提供的flashmessage app等。这里就不再演示了。</p>
<h2 id="title_1-12">删除Todo<a class="anchor" href="#title_1-12">&para;</a></h2>
<p>删除比较简单，不需要处理模板，修改views.py代码:</p>
<pre class="prettyprint"><code>def delete(self, id):
    todo = self.model.get(int(id))
    if not todo:
        error('没找到这条记录')
    todo.delete()
    return redirect(url_for(Todo.index))</code></pre>
<p>先检查是否id存在，然后删除，接着重定向。</p>
<h2 id="title_1-13">简单重构<a class="anchor" href="#title_1-13">&para;</a></h2>
<p>上面的修改和删除都会判断id是否存在，那么可以提成一个函数，函数以_开头就可以了， 所以views.py的最后版本为:</p>
<pre class="prettyprint"><code>#coding=utf-8
from uliweb import expose

@expose('/todo')
class Todo(object):
    def __init__(self):
        from uliweb.orm import get_model

        self.model = get_model('todo')

    @expose('/')
    def index(self):
        return {'todos':self.model.all()}

    def new(self):
        title = request.POST.get('title')
        if not title:
            error('标题是必须的')
        todo = self.model(title=title)
        todo.save()
        return redirect(url_for(Todo.index))

    def _get_todo(self, id):
        todo = self.model.get(int(id))
        if not todo:
            error('没找到这条记录')
        return todo

    def edit(self, id):
        todo = self._get_todo(id)
        if request.method == 'GET':
            return {'todo':todo}
        else:
            title = request.POST.get('title')
            if not title:
                error('标题是必须的')
            todo.title = title
            todo.save()
            return redirect(url_for(Todo.index))

    def delete(self, id):
        todo = self._get_todo(id)
        todo.delete()
        return redirect(url_for(Todo.index))</code></pre>
<h2 id="title_1-14">再说一说URL的定义<a class="anchor" href="#title_1-14">&para;</a></h2>
<p>因为我使用了class view方式，所以你基本上看不到复杂的URL的定义，那么在web.py的版 本中是如何的呢:</p>
<pre class="prettyprint"><code>pre_fix = 'controllers.'

urls = (
    '/',                    pre_fix + 'todo.Index',
    '/todo/new',            pre_fix + 'todo.New',
    '/todo/(\d+)',          pre_fix + 'todo.View',
    '/todo/(\d+)/edit',     pre_fix + 'todo.Edit',
    '/todo/(\d+)/delete',   pre_fix + 'todo.Delete',

)</code></pre>
<p>这里可以看到它使用的是正则式，标准的正则式，和django一样。那么如果在Uliweb中定义 象上面的URL会是什么样子:</p>
<pre class="prettyprint"><code>/todo/&lt;int:id&gt;
/todo/&lt;int:id&gt;/edit
/todo/&lt;int:id&gt;/delete</code></pre>
<p>就是这个样子。Uliweb中的URL定义也是来自于werkzeug，它是一种简化的定义方式，我认 为比原始的正则式要简单很多。</p>
<h2 id="title_1-15">后记<a class="anchor" href="#title_1-15">&para;</a></h2>
<p>非常感谢Ken提供了Todo的web.py的教程，才使得Uliweb版本的教程得以出现。我一直很想 把有关class view的内容讲得更清楚，这次多少涉及了大部分，还有一些没有涉及。另外就 是如何利用我已经实现的一些app来简化开发。从上面的处理可以看到，最基本的就是：CRUD 的操作了。django是通过generic view和admin来实现。Uliweb目前也有一个类似的generic view的东西，我想有机会在下一个提高教程中向大家展示这个东西。当然，它会基于更多的 依赖，所以未必会适合你，但是却是一个我认为不错的扩展的思路。</p>
<p>写得比较仓促，欢迎与我讨论。程序代码可以从 <a href="https://github.com/limodou/uliweb-doc" class="outter">https://github.com/limodou/uliweb-doc</a> 中的simple_todo中找到，包括我使用sphinx写的教程。</p>

        
        <div class="ui blue inverted small label">
            <i class="icon download"></i><a href="./basic.md">View Source</a>
        </div>
        
    </div>
</div>

<div class="ui page grid">
    <div class="column">
    <!-- disqus -->
    
        <div id="disqus_thread" style="margin:20px;"></div>
 <script type="text/javascript">
     /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
     var disqus_shortname = 'uliwebdoc'; // required: replace example with your forum shortname

     /* * * DON'T EDIT BELOW THIS LINE * * */
     (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
 </script>
 <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
 <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    
    </div>
</div>

<div class="ui page grid" id="footer">
    <div class="column">
    
  <div class="ui three column stackable grid">
    <div class="column">
      <div class="ui header">Library</div>
      <div class="ui inverted link list">
        <a target="_blank" class="item" href="http://github.com/limodou/par">Par</a>
        <a target="_blank" class="item" href="http://github.com/limodou/parm">Parm</a>
        <a target="_blank" class="item" href="http://github.com/limodou/plugs">Plugs</a>
      </div>
    </div>
    <div class="column">
      <div class="ui header">Community</div>
      <div class="ui inverted link list">
        <a target="_blank" class="item" href="https://groups.google.com/forum/#!forum/uliweb">Mailing List</a>
        <a target="_blank" class="item" href="http://uliweb.clkg.org">Forum</a>
        <a target="_blank" class="item" href="http://shang.qq.com/wpa/qunwpa?idkey=25e50afc62437ff8579fec79cf794300b6c03e8d3e3f89ca235cbe43e4a72ac0"><img border="0" src="http://pub.idqqimg.com/wpa/images/group.png" alt="Uliweb@Python" title="Uliweb@Python"></a>

      </div>
    </div>
    <div class="column">
      <div class="ui header">Contact Us</div>
      <addr>
        Designed by <a href="mailto:limodou@gmail.com">Limodou</a> <br>
        Rendered by Par and Parm. <br>
        CSS framework <a href="http://semantic-ui.com/">Semantic-UI</a>
      </addr>
    </div>
  </div>

    </div>
</div>


<script type="text/javascript" src="./static/jquery-1.7.2.min.js"></script>
<script type="text/javascript" src="./static/semantic/javascript/semantic.min.js"></script>
<script src="./static/asset/prettify.js"></script>
<script src="./static/toc/toc.js"></script>
<script src="./static/docs.js"></script>
<script src="./static/comment.js"></script>
<script src="./static/jquery.hotkeys.js"></script>
<script src="./static/jquery.sticky-kit.min.js"></script>
<script src="./../static/jquery.cookie.js"></script>


    <script type="text/javascript">
   /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
   var disqus_shortname = 'uliwebdoc'; // required: replace example with your forum shortname

   /* * * DON'T EDIT BELOW THIS LINE * * */
   (function () {
       var s = document.createElement('script'); s.async = true;
       s.type = 'text/javascript';
       s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
       (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
   }());
   </script>



<script>
$(function(){
    $('.navbar .ui.dropdown').dropdown({
        on: 'hover'
    });
    $('a.language').on('click', function(){
        $.cookie('language', $(this).data('lang'), { expires: 360, path: '/' });
        window.location.href = "./../"+$(this).data('lang')+'/index.html';
    });
});
</script>
</body>
</html>
